package main

import (
	"bufio"
	"crypto/tls"
	_ "flag"
	"fmt"
	"io"
	_ "io/ioutil"
	"net/http"
	"os"
	"strings"
	"sync"
	"time"
)

var mu sync.Mutex
var wg sync.WaitGroup

var payload []string = make([]string, 0)

var target []string = make([]string, 0)
var payloadNum int
var targetNum int

func task() {
	tr := &http.Transport{
		TLSClientConfig: &tls.Config{
			InsecureSkipVerify: true,
		},
	}
	//设置请求超时时间
	timeout := time.Duration(3000 * time.Millisecond) //超时时间50ms

	//设置请求
	client := &http.Client{Transport: tr, Timeout: timeout}

	for i := 0; i < targetNum; i++ {
		for j := 0; j < payloadNum; j++ {

			//fmt.Println(baseurl)
			httpUrl, httpsUrl := getPayload(i, j)
			go scan(httpUrl, httpsUrl, client)

		}
	}
}

func main() {

	initData()
	fmt.Println(targetNum, payloadNum)
	wg.Add(targetNum * payloadNum)
	task()

	wg.Wait()


}

func scan(httppayload string, httpspyload string, client *http.Client) {


	resp, err := client.Get(httppayload)
	if err == nil {
		if resp.StatusCode == 200 {
			fmt.Println("200         ", httppayload)
		}
	}else {
		//fmt.Println(err)
	}

	resp, err = client.Get(httpspyload)
	if err == nil {
		if resp.StatusCode == 200 {
			fmt.Println("200         ", httpspyload)
		}
	}else {
		//fmt.Println(err)
	}

	wg.Done()
}

func getPayload(curtarget int, curpayload int) (string, string) {

	mu.Lock()
	baseurl := "http://" + target[curtarget] + payload[curpayload]
	httpurl := strings.Replace(baseurl, "\n", "", -1)
	httpurl = strings.Replace(httpurl, "\r", "", -1)

	baseurl = "https://" + target[curtarget] + payload[curpayload]
	httpsurl := strings.Replace(baseurl, "\n", "", -1)
	httpsurl = strings.Replace(httpsurl, "\r", "", -1)
	mu.Unlock()
	return httpurl, httpsurl

}

func initData() {
	payloadNum = 0
	targetNum = 0
	payloadFile := "E:\\golang\\goproject\\TPexploit\\payload.txt"
	targetFile := "E:\\golang\\goproject\\TPexploit\\target.txt"
	t_fp, err := os.Open(targetFile)
	if err != nil {
		panic(err)
	}
	defer t_fp.Close()
	p_fp, err := os.Open(payloadFile)
	if err != nil {
		panic(err)
	}
	defer p_fp.Close()
	t_buf := bufio.NewReader(t_fp)
	p_buf := bufio.NewReader(p_fp)
	//var line string
	for {
		line, err := p_buf.ReadString('\n')
		if err != nil || err == io.EOF {
			break
		}
		payloadNum += 1
		line = strings.Replace(line, "\n", "", -1)
		payload = append(payload, line)
	}
	for {
		line, err := t_buf.ReadString('\n')
		if err != nil || err == io.EOF {
			break
		}
		targetNum += 1
		line = strings.Replace(line, "\n", "", -1)
		target = append(target, line)
	}
}
